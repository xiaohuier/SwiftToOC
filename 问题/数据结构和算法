
1.数据结构的存储一般常用的有几种？各有什么特点？
2.集合结构 线性结构 树形结构 图形结构
3.单向链表 双向链表 循环链表
4.数组和链表区别
5.堆、栈和队列
6.输入一棵二叉树的根结点，求该树的深度？
7.输入一课二叉树的根结点，判断该树是不是平衡二叉树

1.时间复杂度
2.空间复杂度
3.常用的排序算法
4.字符串反转
5.链表反转（头差法）
6.有序数组合并
7.查找第一个只出现一次的字符（Hash查找）
8.查找两个子视图的共同父视图
9.无序数组中的中位数(快排思想)
10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

1. 数学实现题
1.1 斐波那契数列实现）
递归和循环都可以实现，递归性能差，N2的，有个公式可以推倒成nlogn
循环注意判断超过2个数

1.2 Binary Search（二分查找）
查找还有斐波那契查找 插值查找，在分布均匀时，按照一个公式 效率高
1.3 Is Prime（是否是质数）
for 循环除以比自己小的数字，性能最差
一个数的一半往后是不存在其因数的 可以优化一半
除以6，如果余数不是1，或者5，那么就都不是素数。性能最好
1.4 Is Ugly Number（是否是丑数）
因为循环除以2，3，5后，余数必须是1才是丑数，可以循环除以
可以做一个数组，顺序保存算出来的。判断数组内所有的数*2，*5 *3哪个最小

1.5 Is Power Of Two（是否是2的幂）
非0数字
return n &&(n&(n-1))
因为2的幂变成2进制会是1000...这样的
1.6 Is Power Of Three（是否是3的幂）
我们不用循环，那么有一个投机取巧的方法，由于输入是int，正数范围是0-231，在此范围中允许的最大的3的次方数为319=1162261467，那么我们只要看这个数能否被n整除即可
1.7 Count Primes（质数的个数）
我们从2开始遍历到根号n，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质数3，标记其所有倍数，一次类推，直到根号n，此时数组中未被标记的数字就是质数。我们需要一个 n-1 长度的 bool 型数组来记录每个数字是否被标记，长度为 n-1 的原因是题目说是小于n的质数个数，并不包括n。
2. Algorithm Implementation Questions (算法实现题)
2.0 Sort Test Demo（排序测试用例）

2.1 Bubble Sort Implementation（冒泡排序实现）

2.2 Selection Sort Implementation（选择排序实现）

2.3 Insertion Sort Implementation（插入排序实现）

2.4 Quick Sort Implementation（快速排序实现）

3. Linked List Questions（链表相关问题）
3.0 Linked List Test Demo（链表类，测试用例）

3.1 Linked List Cycle（链表是否有环）
这道题是快慢指针的经典应用。只需要设两个指针，一个每次走一步的慢指针和一个每次走两步的快指针，如果链表里有环的话，两个指针最终肯定会相遇。
然后找到任何一个环内的节点后，走一圈就能确定环的节点数量
找到环的入口节点
让快指针走环的数量的个数，然后一起前进，相遇点就是环的入口

3.2 Intersection Of Two Linked Lists（两个链表的交点）
如果有公共交点，那么把2个链表分别放入2个栈里面，然后一个个POP栈顶，第一个不相等的就是分开的时候
先遍历一遍2个链表节点的数量，让长的先走几步，然后一个个对比是不是相等
3.3 Reverse Linked List（反转链表）
定义三个指针，分别指向前中后，三个节点，然后再反转
3.4 Merge Two Linked Lists（合并两个排序的链表）
递归来做，如果1的头节点小于2，那么链表1的头节点，就是合并后链表的头节点
3.5 Find the Kth to tail in Linked List（找到链表的倒数第K个节点）
暴力方法，遍历2次链表
搞2个指针，第一个走k部，然后后面的在一起前进
3.6 Recursively Print Linked List（倒序打印链表）
递归判断是不是有next。有的话打印
3.7 Remove Nth From End Of Linkded List（删除链表倒数第N个节点）
先找到，再删除，注意头尾
3.8 Delete Node in a Linked List（删除链表里某个节点）
循环下去，找到那个节点，把下个节点的值copy过来，然后删掉下一个
或者找到上一个，接上下一个
3.9 Remove Duplicates I（删除链表内重复的节点，保留单个节点）
递归的判断当前节点在前面的链表里面，有没有重复，有就删掉自己，知道链表到头
3.10 Remove Duplicates II（删除链表内所有重复的节点）
1.hash_map 统计出现次数，如果出现次数等于1，那么就放在新链表后面。
2.定义一个 dummy 头结点，链接上原链表，cur 指向原链表头部
① 当前结点value ！= 当前结点的下一结点value。那么让pre指针来到当前结点，这样就链接了前一结点和当前结点。然后当前结点移至下一结点
② 当前结点value == 当前结点的下一结点value。那么就让 cur 一直往下走直到 当前结点value ！= 当前结点的下一结点value，然后此时是不能动 pre 指针的，要避免后面还有重复的，所以让 pre->next = cur->next。然后当前结点移至下一结点。
3. head 后面有值而且和 head 的值相等，那么就找到不相等为止，然后对后面一个结点去递归，这样就把前面重复的给删除了。
head 后面有值但和 head 的值不等，那么就递归后面一个结点，接在 head 的后面
最后返回 head

3.11 Remove Linked List Elements（删除链表里某个值的所有节点）
循环一次
3.12 Partition Linked List（左右临界值分离）

3.13 Old Even List（左右奇偶index的值分离）
排序，需要循环，判断比较，交换。本题对排序算法的排序条件的掌握，将常规排序条件从比大小变为判断奇偶。
思路：题目要求偶数在前，奇数在后，那么我选择采取双指针的方法：
左指针寻找奇数值，右指针寻找偶数值，当符合交换条件时，进行两数交换；
否则指针继续左右运动，寻找符合条件的奇偶值。
当两指针相遇时，结束循环。
4. Array Questions（数组相关问题）
4.0 Array Test Demo

4.1 Contains Duplicate I（检测数组中是否包含重复的元素）
1.数组先排序。。然后遍历一遍
2.创建一个hash表
3.数组在n的返回内，然后从头开始，把数组n交换到n的位置去
4.把数组按n/2分成大小份，然后判断数量是不是大于n，然后以此类推
4.2 Majority Element（出现次数超过数组长度一半的元素）
先排序，算下排序后数据都是个，然后返回中间的那个元素
哈希表
4.3 Single Number（数组中只出现过一次的数字）
按位操作，2个相同的数字按位出现，会= 0
哈希表去重后，相加*2 - 数组
4.4 Missing Number (寻找数组中缺失的数字)
找到最大的那个数字，然后从1到大数除以数组
4.5 Move Zeros (将所有的0移动到数组末尾)
开辟一个新数组，然后遍历

4.6 Remove Element (移除数组中等于某个值的元素)
遍历一遍，然后把遇到的移动到最后一个去
4.7 Sort Colors（三色旗问题）
遇到0就到左边，2到右边，1不动
4.8 Two Sum II（有序数组内部的两个元素的和为目标值）
先去掉比当前大的，然后2个指针分别在头尾跳
4.9 Minimum Sub Array Sum（无序数组和大于或等于某值的最小子数组）
这里是用一前一后两个指针都从左往右移，前面的指针一直移直到和大于s为止；后面的指针此时一直右移，直到距离最短为止。最后返回最小子数组的大小，也就是最小子数组中元素个数。
4.10 Intersection of Two Arrays（两个数组的交点元素）
这个想法是将两个数组都转换成集合，然后遍历最小的集合，检查更大集合中每个元素的存在。 在平均情况下，此方法的时间复杂度为\ mathcal {O}（n + m）O（n + m
4.11 The Top Kth Frequent Element (出现频率最高的第k个元素)
构建一个哈希图元素->它的频率。
建立一个堆。
输出
4.12 The Kth Largest Element(数组中第k大的元素)
桶排序，非常好理解，先遍历一遍数组找出最大最小值。创建一个桶，长度为max-min+1，桶的索引对应于与Min的差值，桶中装的元素为该值出现次数。
4.13 Merge Two Sorted Array (合并两个有序的数组)

4.14 Two Sum I（无序数组内部的两个元素的和为目标值）
使用hash表存储遍历过的元素，遍历数组中的每一个元素，当遍历该元素时，去hash表中进行查找，是否存在某个元素与当前元素之和与目标值相等。时间复杂为o(n)，因为我们只需要遍历一遍数组即可，但是空间复杂度为o(n)。典型的以空间换取时间。

5. Binary Tree Questions（二叉树相关问题）
5.1 Maximum Depth of Binary Tree（二叉树的深度）
递归去判断左右子树存不存在
5.2 Invert Binary Tree（反转二叉树）
递归翻转一个二叉树，就是把根节点的左子树翻转一下，同样的把右子树翻转一下，在交换左右子树就可以了。
5.3 Balanced Binary Tree（是否是平衡二叉树）
递归计算树的深度，同时判断是否为平衡二叉树，
5.4 Symmetric Tree（是否是镜像树）
递归判断左子树的左孩子，是不是等于右子树的右孩子
5.5 Is Same Tree（树是否相等）
递归判断当前树的左子树是不是相等，右边也是

6. String Questions（字符串相关问题）
6.1 Reverse String（反转字符串）
2个指针，分别指向头尾，然后交换
6.2 替换字符串
先遍历一遍字符串，算出来替换后的长度
然后初始化新数组后，挨个存进去

答：
1.从管理方式来讲
对于栈来讲，是由编译器自动管理，无需我们手工控制；
对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)
2.从申请大小大小方面讲
栈空间比较小
堆控件比较大
3.从数据存储方面来讲
栈空间中一般存储基本类型，对象的地址
堆空间一般存放对象本身，block的copy等

# 堆
堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：

1）堆中某个节点的值总是不大于或不小于其父节点的值；
2）堆总是一棵完全二叉树。
堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。
堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。

# 栈
栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。
栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。
堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。
栈的应用—递归

# 队列
队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。
队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。


# 排序
交换排序 冒泡排序 算法复杂度O（n*2），最好O（n）稳定， 空间复杂度1 N越到越好
重复走过要访问的数列，一次比较2个元素，如果顺序错误，就把它们交换过来
选择排序
现在莫排序列找到最小元素，放到起始位置
插入排序 直接插入 算法复杂度O（n*2），最好O（n）稳定， 空间复杂度1 N越到越好
从已知的序列中扫描，把数据插入到对应位置
堆排序
把数据改成最大堆
然后反复的把根节点移走，然后剩下的组成一个新的堆
归并排序 分而治之 先把数组分成2部分，分别排序后，合并数组
快速排序
从数组中选一个元素当基准
然后把必基准元素小的和大的分成2份 进行分区
然后分区递归执行上面的，知道还剩3个元素
