自我介绍
你好，我叫周正东，毕业于杭州电子科技大学，从2016年开始从事iOS开发工作，先是在杭州创业公司工作了一年后，来到上海PPTV工作了2年，主要负责的是播放器应用的开发。出于个人发展的考虑，希望能找到已经发展的臻臻日上的公司工作

主要工作
在创业公司，从0开始开发了一款P2P投资类App。从研发，测试到打包，审核等工作。
主要给App选择了MVVM的架构模式，写了许多用来复用的基类，baseview，basevc等。。
写的比较好的有，签到模块，网络请求模块（以block的形式回调，封装了超时时常，缓存策略），封装了通用的弹框UI库。封装了不同navibar的切换，和一些动画的实现，首页立体的page等
PPTV主要工作
前期负责PPTV app的播放器功能，和下载，登陆等功能
登陆就是普通的UI开发，发请求，请求合并等
下载功能，主要是本地数据库fmdb的使用，大批量数据刷新时，需要使用事务操作来提高速度，数据库的线程安全和数据的迁徙
pptv 播放器
播放器需要的东西
1.一个解码播放器，类似于avplayer，但是avplayer格式支持的不好，rtmp，flv等不支持，所有就有了自有播放器，3d播放器，投屏播放器等
2.需要又一个获取播放串的接口服务，还包括了加密，防盗，添加广告等一系列接口服务。。。
3.播放器起播前后，和用户的交互，会有一系列UI需要实现
pptv 老播放器
因为代码迭代了很久，从最早一个xib的vc开始，慢慢发展成了数个具有继承关系的大类，组成了播放器。
刚开始是有好几个大类，完成了全部工作，然后是有人发现了上万行的代码，难以维护，开始使用kvo来监听播放器的形式，写了一个业务类，但是因为各个业务的耦合很大，最后就变成了播放器耦合所有业务，组件类通过播放器来进行交互。
全局变量多，import文件多，一个变量，出现异常的变化时，不好定位问题，存在一些超级大方法，if else多，不好改
并且存在一个不好研究的kvo crash
然后，开始变成中台服务后，设计了一套播放器架构
PPTVBasePlayer
这部分是对于avplayer等的一种封装，消灭了不同播放器接口不一致带来的问题，并且给状态回调和监听带来了统一的接口，例如avplayer，有些需要kvo item，有些需要添加异步key等。。。
这时候的播放器，需要提供一个播放器就可以起播。他基本只提供一个view
SNOnePlayer
这是对播放器一系列接口的封装，也把这部分功能给不同的业务方集成。例如pptv。pp体育，苏宁易购等
这里主要处理的是数据的流动。从外界给一个id开始，根据id的不同，场景不同，请求不同的接口，获取不同格式的数据流，然后初始化不同的baseplayer，提供了很多，数据上报，错误收集等
因为数据的流动是一个高异步的场景，接口的同步，异步，外界的取消，刷新等。。。。
所以选择了Ribs架构来做。他是对于viper设计模式的改编，传统的mvc，mvvm等都以vc作为核心，视图为驱动。但是对于播放器页面和一些业务组件，几乎没有页面的，就很不适用

PPTVCorePlayer技术方案
这是我写的一个sdk，pptv的老播放器有重构的需求，而且我对于老播放器问题的第三点进行了优化，设计了一套组件化架构
我认为播放器上面有许许多多的UI控件，以业务进行划分，比如，手势，控制栏等，作为组件
播放器的场景好多个，使用的业务功能部分一样，部分不一样。因为设计模式中，要对修改关闭，添加开发的原则，就把这些组件化，然后播放器来选择自己需要使用的组件，来构成播放器
组件的设定，借鉴了beehiv的组件，组件通过实现一个协议来描述，协议只有一个必须方法name，和一些可选的依赖注入，例如组件需要使用视图foorlayers，方法回调，kvo属性，等等

组件本身封装一部分业务，那么完成业务需要一些依赖。例如对播放器操作，暂停之类的，对播放器进行状态读取，显示进度条等，对播放器事件进行监听，显示loading圈。
组件还需要一些其他时间，例如组件间事件传递。外界的事件，转屏等
前面的三个，是onePlayer来提供的。对oneplayer部分的功能进行了封装，把对播放器的操作，封装成handler，对播放器状态的读取，封装成status属性，事件回调，通过proxy进行转发，实现一个管理组件视图的Follerviews
然后播放器的4个可选方法，setstatuscontoller，setplayhandler，setFollerview，observerkey，observerAction传递给播放器
第四点，就需要播放器来提供。组件需要播放器来实现自己的依赖事件。例如anmationshow等等，通过公共协议来复用，最后在播放器里面实现
然后播放器的状态会改变，dlna，音频，视频模式会变化，这时候我就设计了一套组件切换的模式
三个状态分别都有自己的组件注册器。每个都维护了一个组件数组，那么组件就会初始化和消亡
然后就给组件添加了一套生命周期，didbecome和resiestactive。然后切换组件时，就把组件注册器释放，然后读取新的组件注册器的组件。通过生命周期和bridgelaodfinish来做状态回复和防止异常事件

playhandler 简单的操作器，oneplayer封装
statuscontoller 实现全部的代理回到，然后维护了一堆属性例如playing，ading，changering，播放器时间timer kvo等
proxy statuscontoller的事件回调，是很多组件所需要的。例如startloading的时候，要显示loading线，状态栏需要组织自己被点击，同时要一致存在不被消失。那么就需要laoding组件，controller，manner都要监听。那么就需要消息多转发，类似于beehiv的appdelegate转发。组件把需要监听的sel以字符串数组来发给proxy
floorview 播放器视图管理器，不同的UI会有上下重叠的问题。。。那么久需要又一个高度不同的views来搭建，类似于书架一样。这里维护一个layzpostion不同的view，作为架子view，然后发个组件，这里出现响应链的问题，重写了hittest

compentcontroller 播放器初始化完成后，组件的初始化，各种依赖的注入等等，compentcontroller来完成。他负责组件的生命周期，和kvo，监听方法的解除

didbecome取代了init和dealloc的好处
组件化后，业务分开写，就能很好的代码分工，大家的不同编码习惯，也没有了影响
组件很多我写的，不是我写的也明白里面的意思

播放器常用格式，及协议
MP4，苹果开发的格式，特点是加载满
HLS M3U8,苹果开发的流格式，M3U8文件用来描述视频，加载多个ts文件来播放，特点是加载速度快，延迟高
RTMP HLV格式，能够3s内的低延迟 专门会流媒体设计的（私有）
RTSP MP4格式，专门为流媒体设计的

设计模式的区别
最早苹果的架构是mvc，其中m指model，负责维护页面的元数据，v指view负责把model的数据在页面上展示出来，vc是中介者，m和v不直接交互，通过vc来做映射，v被点击后，同志model来做解析
但是在ios通常情况下，view是纯页面，model是纯数据格式，那么类似于网络请求，数据格式转换处理等业务很多都在vc中，vc还要负责页面跳转等业务，就会很大，所以不方便

mvvm分2种，常见用法，是把view和vc都认为是view，然后原本vc里面的网络请求等逻辑封装到vm里面，vm里面改遍布model，然后通知views来改变
微软在写出来reactive概念一样，提出了mvvm
v和m是不变的，添加了一个vm的概念vm负责把自身的属性，通过rx库来和view绑定，实现从模型到View自动变化
其他的mvp接触不多
viper有些变化。它存在很多个组件，model，view，Interactor，Router，Presenter
它以Presenter作为核心，Presenter负责来改变view，持有Router做跳转，Interactor发请求和其他业务。
同时模块内以协议的形式把组件隔开，可以小粒度的进行单元测试
但是iOS本身做一个模块，就些这么多类，需要添加许许多多的初始化方法，代码很麻烦

Ribs，他是对viper的变种
与界面Presenter驱动的viper不一样，他是以数据Interactor为驱动的
组件包含Router，Interactor，Build，和一些可选的组件，Presenter，Model，View，Commenpent等等。
以业务数据为驱动，意思是业务总是从一个状态流转向下一个状态，或者返回上一层，比如播放器，总是先初始化，然后请求，然后拼接播放串，然后起播，结束。。
每一个状态，对应一个ribs组件，Build负责初始化一系列的组件，并且完成依赖注入。
第一个节点是外界初始化的，
每一个节点，在builder完成后，都持有下一个节点的router
router调用下个节点的builder方法来创建下个节点的全部组件，然后需要使用时，跳转过去
Interactor是当前节点的业务类，他持有下一个节点的事件流，进行调用，也是子节点的回调监听者
当节点的业务完成后，Interactor就会被释放，他有willregist和didbecomeactive的生命周期
子Router会被父Router持有，形成一个树形结构。
那么路由的跳转就是业务的跳转，可以包含vc的跳转，看下个节点的实现
多个节点可以共享一个Presenter，这在路由跳转时，把对象注入过去了
因为每个节点和组件件进行了协议的解耦，在多个业务备份的时候，非常好用
我主要开发了请求播放串的部分节点，运营商，错误收集节点
其中播放串的部分节点的状态分为，Start，持有运营商，play接口请求，play接口解析三个子节点
这时候会遇到多异步的场景。。。介绍下rac

rac
RAC就是Cocoa框架下的函数响应式编程的实现。它提供了基于时间变化的数据流的组合和变化。
函数式，和指令式相对。前者是递归，后者是for循环，他只用"表达式"，不用"语句"，没有副作用，不得修改外部变量的值。
响应式。计算是相互的，当一个量发生变化，其他的也会连带着发生变化，他会是return self的链式调用，类似于masonry
RAC中Pull-driver和Push-driver的区别？在RAC里面，Sequence就是一个pull-driver，Signal就是一个push-driver。
RAC的核心的一个函数，bind操作：订阅原始的信号。，任何时刻原始信号发送一个值，都会绑定的block转换一次。一旦绑定的block转换了值变成信号，就立即订阅，并把值发给订阅者subscriber。一旦绑定的信号要终止绑定，原始的信号就complete。
常用函数 Map（信号的改变），combineLatest（合并多个信号后订阅最后一个），flattenMap（先升阶再降阶），merge 信号的合并
RACCommand 适合封装网络请求，返回的是信号的信号
常用宏 onExit RACTuplePack  weakify、unsafeify、strongify
冷信号和热信号的概念 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。
冷信号转换成热信号 RACMulticastConnection类来使用，有方法replay publish等
信号的订阅本质是一个信号转换成另一个新的，然后行程订阅关系
热信号需要注意内存的泄漏
rac的缺点，没有性能提升，函数调用堆栈长。。。学习成本高，要注意循环引用（block），要团队形成套路
好处，rac是基于时间变化的数据流，那么在高异步的场景。封装好的函数实现好的功能（flattenMap，retry，dispose的使用），能节约变量和减少bug
