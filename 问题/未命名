自我介绍
你好，我叫周正东，毕业于杭州电子科技大学，从2016年开始从事iOS开发工作，先是在杭州创业公司工作了一年后，来到上海PPTV工作了2年，主要负责的是播放器应用的开发。出于个人发展的考虑，希望能找到已经发展的臻臻日上的公司工作

主要工作
在创业公司，从0开始开发了一款P2P投资类App。从研发，测试到打包，审核等工作。
主要给App选择了MVVM的架构模式，写了许多用来复用的基类，baseview，basevc等。。
写的比较好的有，签到模块，网络请求模块（以block的形式回调，封装了超时时常，缓存策略），封装了通用的弹框UI库。封装了不同navibar的切换，和一些动画的实现，首页立体的page等
PPTV主要工作
前期负责PPTV app的播放器功能，和下载，登陆等功能
登陆就是普通的UI开发，发请求，请求合并等
下载功能，主要是本地数据库fmdb的使用，大批量数据刷新时，需要使用事务操作来提高速度，数据库的线程安全和数据的迁徙
pptv 播放器
播放器需要的东西
1.一个解码播放器，类似于avplayer，但是avplayer格式支持的不好，rtmp，flv等不支持，所有就有了自有播放器，3d播放器，投屏播放器等
2.需要又一个获取播放串的接口服务，还包括了加密，防盗，添加广告等一系列接口服务。。。
3.播放器起播前后，和用户的交互，会有一系列UI需要实现
pptv 老播放器
因为代码迭代了很久，从最早一个xib的vc开始，慢慢发展成了数个具有继承关系的大类，组成了播放器。
刚开始是有好几个大类，完成了全部工作，然后是有人发现了上万行的代码，难以维护，开始使用kvo来监听播放器的形式，写了一个业务类，但是因为各个业务的耦合很大，最后就变成了播放器耦合所有业务，组件类通过播放器来进行交互。
全局变量多，import文件多，一个变量，出现异常的变化时，不好定位问题，存在一些超级大方法，if else多，不好改
并且存在一个不好研究的kvo crash
然后，开始变成中台服务后，设计了一套播放器架构
PPTVBasePlayer
这部分是对于avplayer等的一种封装，消灭了不同播放器接口不一致带来的问题，并且给状态回调和监听带来了统一的接口，例如avplayer，有些需要kvo item，有些需要添加异步key等。。。
这时候的播放器，需要提供一个播放器就可以起播。他基本只提供一个view
SNOnePlayer
这是对播放器一系列接口的封装，也把这部分功能给不同的业务方集成。例如pptv。pp体育，苏宁易购等
这里主要处理的是数据的流动。从外界给一个id开始，根据id的不同，场景不同，请求不同的接口，获取不同格式的数据流，然后初始化不同的baseplayer，提供了很多，数据上报，错误收集等
因为数据的流动是一个高异步的场景，接口的同步，异步，外界的取消，刷新等。。。。
所以选择了Ribs架构来做。他是对于viper设计模式的改编，传统的mvc，mvvm等都以vc作为核心，视图为驱动。但是对于播放器页面和一些业务组件，几乎没有页面的，就很不适用

PPTVCorePlayer技术方案
这是我写的一个sdk，pptv的老播放器有重构的需求，而且我对于老播放器问题的第三点进行了优化，设计了一套组件化架构
我认为播放器上面有许许多多的UI控件，以业务进行划分，比如，手势，控制栏等，作为组件
播放器的场景好多个，使用的业务功能部分一样，部分不一样。因为设计模式中，要对修改关闭，添加开发的原则，就把这些组件化，然后播放器来选择自己需要使用的组件，来构成播放器
组件的设定，借鉴了beehiv的组件，组件通过实现一个协议来描述，协议只有一个必须方法name，和一些可选的依赖注入，例如组件需要使用视图foorlayers，方法回调，kvo属性，等等

组件本身封装一部分业务，那么完成业务需要一些依赖。例如对播放器操作，暂停之类的，对播放器进行状态读取，显示进度条等，对播放器事件进行监听，显示loading圈。
组件还需要一些其他时间，例如组件间事件传递。外界的事件，转屏等
前面的三个，是onePlayer来提供的。对oneplayer部分的功能进行了封装，把对播放器的操作，封装成handler，对播放器状态的读取，封装成status属性，事件回调，通过proxy进行转发，实现一个管理组件视图的Follerviews
然后播放器的4个可选方法，setstatuscontoller，setplayhandler，setFollerview，observerkey，observerAction传递给播放器
第四点，就需要播放器来提供。组件需要播放器来实现自己的依赖事件。例如anmationshow等等，通过公共协议来复用，最后在播放器里面实现
然后播放器的状态会改变，dlna，音频，视频模式会变化，这时候我就设计了一套组件切换的模式
三个状态分别都有自己的组件注册器。每个都维护了一个组件数组，那么组件就会初始化和消亡
然后就给组件添加了一套生命周期，didbecome和resiestactive。然后切换组件时，就把组件注册器释放，然后读取新的组件注册器的组件。通过生命周期和bridgelaodfinish来做状态回复和防止异常事件

playhandler 简单的操作器，oneplayer封装
statuscontoller 实现全部的代理回到，然后维护了一堆属性例如playing，ading，changering，播放器时间timer kvo等
proxy statuscontoller的事件回调，是很多组件所需要的。例如startloading的时候，要显示loading线，状态栏需要组织自己被点击，同时要一致存在不被消失。那么就需要laoding组件，controller，manner都要监听。那么就需要消息多转发，类似于beehiv的appdelegate转发。组件把需要监听的sel以字符串数组来发给proxy
floorview 播放器视图管理器，不同的UI会有上下重叠的问题。。。那么久需要又一个高度不同的views来搭建，类似于书架一样。这里维护一个layzpostion不同的view，作为架子view，然后发个组件，这里出现响应链的问题，重写了hittest

compentcontroller 播放器初始化完成后，组件的初始化，各种依赖的注入等等，compentcontroller来完成。他负责组件的生命周期，和kvo，监听方法的解除

didbecome取代了init和dealloc的好处
组件化后，业务分开写，就能很好的代码分工，大家的不同编码习惯，也没有了影响
组件很多我写的，不是我写的也明白里面的意思

播放器常用格式，及协议
MP4，苹果开发的格式，特点是加载满
HLS M3U8,苹果开发的流格式，M3U8文件用来描述视频，加载多个ts文件来播放，特点是加载速度快，延迟高
RTMP HLV格式，能够3s内的低延迟 专门会流媒体设计的（私有）
RTSP MP4格式，专门为流媒体设计的

设计模式的区别
数据管理者，数据加工者，数据展示者
MVC（Model-View-Controller）是最老牌的的思想，老牌到4人帮的书里把它归成了一种模式，其中Model就是作为数据管理者，View作为数据展示者，Controller作为数据加工者，Model和View又都是由Controller来根据业务需求调配，所以Controller还负担了一个数据流调配的功能。

M应该做的事：
给ViewController提供数据
给ViewController存储数据提供接口
提供经过抽象的业务基本组件，供Controller调度

C应该做的事：
管理View Container的生命周期
负责生成所有的View实例，并放入View Container
监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。

V应该做的事：
响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。
界面元素表达

MVCS
从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。
这算是瘦Model的一种方案，瘦Model只是专门用于表达数据，然后存储、数据处理都交给外面的来做。MVCS使用的前提是，它假设了你是瘦Model，同时数据的存储和处理都在Controller去做。所以对应到MVCS，它在一开始就是拆分的Controller。因为Controller做了数据存储的事情，就会变得非常庞大，那么就把Controller专门负责存取数据的那部分抽离出来，交给另一个对象去做，这个对象就是Store。这么调整之后，整个结构也就变成了真正意义上的MVCS。

胖Model包含了部分弱业务逻辑。胖Model要达到的目的是，Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上。
瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller

MVVM （M VM C V）
MVVM去年在业界讨论得非常多，无论国内还是国外都讨论得非常热烈，尤其是在ReactiveCocoa这个库成熟之后，ViewModel和View的信号机制在iOS下终于有了一个相对优雅的实现。MVVM本质上也是从MVC中派生出来的思想，MVVM着重想要解决的问题是尽可能地减少Controller的任务。不管MVVM也好，MVCS也好，他们的共识都是Controller会随着软件的成长，变很大很难维护很难测试。只不过两种架构思路的前提不同，MVCS是认为Controller做了一部分Model的事情，要把它拆出来变成Store，MVVM是认为Controller做了太多数据加工的事情，所以MVVM把数据加工的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。

MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。关于这个观点我要做一个额外解释：胖Model做的事情是先为Controller减负，然后由于Model变胖，再在此基础上拆出ViewModel，跟业界普遍认知的MVVM本质上是为Controller减负这个说法并不矛盾，因为胖Model做的事情也是为Controller减负。

在MVVM中使用ReactiveCocoa的第一个目的就是如上所说，View并不适合直接持有ViewModel。第二个目的就在于，ViewModel有可能并不是只服务于特定的一个View


viper有些变化。它存在很多个组件，model，view，Interactor，Router，Presenter
它以Presenter作为核心，Presenter负责来改变view，持有Router做跳转，Interactor发请求和其他业务。
同时模块内以协议的形式把组件隔开，可以小粒度的进行单元测试
但是iOS本身做一个模块，就些这么多类，需要添加许许多多的初始化方法，代码很麻烦


Ribs，他是对viper的变种
与界面Presenter驱动的viper不一样，他是以数据Interactor为驱动的
组件包含Router，Interactor，Build，和一些可选的组件，Presenter，Model，View，Commenpent等等。
以业务数据为驱动，意思是业务总是从一个状态流转向下一个状态，或者返回上一层，比如播放器，总是先初始化，然后请求，然后拼接播放串，然后起播，结束。。
每一个状态，对应一个ribs组件，Build负责初始化一系列的组件，并且完成依赖注入。
第一个节点是外界初始化的，
每一个节点，在builder完成后，都持有下一个节点的router
router调用下个节点的builder方法来创建下个节点的全部组件，然后需要使用时，跳转过去
Interactor是当前节点的业务类，他持有下一个节点的事件流，进行调用，也是子节点的回调监听者
当节点的业务完成后，Interactor就会被释放，他有willregist和didbecomeactive的生命周期
子Router会被父Router持有，形成一个树形结构。
那么路由的跳转就是业务的跳转，可以包含vc的跳转，看下个节点的实现
多个节点可以共享一个Presenter，这在路由跳转时，把对象注入过去了
因为每个节点和组件件进行了协议的解耦，在多个业务备份的时候，非常好用
我主要开发了请求播放串的部分节点，运营商，错误收集节点
其中播放串的部分节点的状态分为，Start，持有运营商，play接口请求，play接口解析三个子节点
这时候会遇到多异步的场景。。。介绍下rac

rac
RAC就是Cocoa框架下的函数响应式编程的实现。它提供了基于时间变化的数据流的组合和变化。
函数式，和指令式相对。前者是递归，后者是for循环，他只用"表达式"，不用"语句"，没有副作用，不得修改外部变量的值。
响应式。计算是相互的，当一个量发生变化，其他的也会连带着发生变化，他会是return self的链式调用，类似于masonry
RAC中Pull-driver和Push-driver的区别？在RAC里面，Sequence就是一个pull-driver，Signal就是一个push-driver。
RAC的核心的一个函数，bind操作：订阅原始的信号。，任何时刻原始信号发送一个值，都会绑定的block转换一次。一旦绑定的block转换了值变成信号，就立即订阅，并把值发给订阅者subscriber。一旦绑定的信号要终止绑定，原始的信号就complete。
常用函数 Map（信号的改变），combineLatest（合并多个信号后订阅最后一个），flattenMap（先升阶再降阶），merge 信号的合并
RACCommand 适合封装网络请求，返回的是信号的信号
常用宏 onExit RACTuplePack  weakify、unsafeify、strongify
冷信号和热信号的概念 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。
冷信号转换成热信号 RACMulticastConnection类来使用，有方法replay publish等
信号的订阅本质是一个信号转换成另一个新的，然后行程订阅关系
热信号需要注意内存的泄漏
rac的缺点，没有性能提升，函数调用堆栈长。。。学习成本高，要注意循环引用（block），要团队形成套路
好处，rac是基于时间变化的数据流，那么在高异步的场景。封装好的函数实现好的功能（flattenMap，retry，dispose的使用），能节约变量和减少bug


App 的启动
main() 函数执行前；
加载可执行文件 .O
加载动态链接库，进行 rebase 指针调整和 bind 符号绑定
Objc运行时处理，类的注册，category的注册，方法唯一性检查
初始化 执行load方法，创建c++全局变量
可以优化的是
减少动态库的调用，尽量将多个动态库进行合并
减少启动后不使用的类和方法
+load方法的调用  ，一个load和方法交换需要4毫秒
换成initialize，或者启动后
减少c++全局变量

如何查看时间
只需要在 Edit scheme -> Run -> Environment Variables 中将环境变量 DYLD_PRINT_STATISTICS 设为 1，就可以看到 main 之前各个阶段的时间消耗
Total pre-main time: 1.1 seconds (100.0%)
         dylib loading time: 599.57 milliseconds (52.0%)
        rebase/binding time: 113.88 milliseconds (9.8%)
            ObjC setup time: 146.33 milliseconds (12.7%)
           initializer time: 291.94 milliseconds (25.3%)
           slowest intializers :
             libSystem.B.dylib :   8.77 milliseconds (0.7%)
               CloudyTrace_IOS :  24.10 milliseconds (2.0%)
                      DSPAdSDK : 163.96 milliseconds (14.2%)
                  P2PFramework :  24.57 milliseconds (2.1%)
                        LZLive :  24.27 milliseconds (2.1%)
                    PPTViPhone : 188.17 milliseconds (16.3%)

应该在400ms内完成main()函数之前的加载
整体过程耗时不能超过20秒，否则系统会kill掉进程，App启动失败

main 前 1.1s
app did finish lunch 0.3s

main() 函数执行后；
直到didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。
主要是
从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行

首屏渲染后
首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束

功能级别的启动优化
化的思路是： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。
启动广告的策略处理
进行三步初始化，必要（日志，首屏，广告，token等）-> 展示首屏 -> 主线程追加 （非线程安全的缓存加载，配置项预加载等）->子线程（后台下载，监控启动）
方法级别的启动优化
是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源

组件化
为什么要做组件化
1.耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）依赖不能倒转
2.容易出现冲突（尤其是使用 Xib，还有就是 Xcode Project，虽说有脚本可以改善）
3.业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）

组件化方案分
协议试
在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践
缺点:
由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要
协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。

中间者架构
另一种常用的架构形式是中间者架构。它采用中间者统一管理的方式，来控制 App 的整个生命周期中组件间的调用关系。

拆分的组件都会依赖于中间者，但是组间之间就不存在相互依赖的关系了。由于其他组件都会依赖于这个中间者，相互间的通信都会通过中间者统一调度，所以组件间的通信也就更容易管理了。在中间者上也能够轻松添加新的设计模式，从而使得架构更容易扩展。

Limboy 方案
采用OpenUrl Params的方式进行页面间的调度
[MGJRouter registerURLPattern:@"mgj://cart/ordercount" toObjectHandler:^id(NSDictionary *routerParamters){
	// do some calculation
	return @42;
}]
件间的调用通过 protocol ，是使用「协议」 <-> 「类」绑定的方式
@protocol MGJCart <NSObject>
+ (NSInteger)orderCount;
@end

组件由 ModuleManager 搞定，loadModuleFromPlist:pathForResource: 方法会读取 bundle 里的一个 plist 文件
每个 Module 都实现了 ModuleProtocol，其中有一个 - (BOOL)applicaiton:didFinishLaunchingWithOptions: 方法，如果实现了的话，就会被调用。
每个组件都有一个 Entry，这个 Entry，主要做了三件事

注册这个组件关心的 URL
注册这个组件能够被调用的方法/属性
在 App 生命周期的不同阶段做不同的响应

需要hardcode来编码哪些url是可以用的
由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖publicProtocol。这对于将来的业务迁移是有非常大的影响的。

CTMediator
使用runtime进行调度
实现一个url到target action的编码规范
不需要注册url这个步骤，因为runtime会自动调度

每一个模块需要实现一个自己可以被调用的tagetaction_a类,把自己能提供的接口给出来

mediator这个repo维护了若干个针对mediator的category，每一个对应一个target，每个category里的方法对应了这个target下所有可能的调用场景

然后mediator的category类中，进行参数检查后，调用performTarget action方法调度到taget类的方法上面

这样调用者在包含mediator的时候，自动获得了所有可用的target-action，无论是调用还是参数传递，都非常方便。
category本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。
在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。
category可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。
category统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。

组件化方案中的去model设计
假设模块A和模块B之间采用model化的方案去调用，那么调用方法时传递的参数就会是一个对象
因此，使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。

在iOS的开发中，就是以字典的方式去传递。这样就能够做到只有调用方依赖mediator，而响应方不需要依赖mediator。然而在去model化的实践中，由于这种方式自由度太大，我们至少需要保证调用方生成的参数能够被响应方理解，然而在组件化场景中，限制去model化方案的自由度的手段，相比于网络层和持久层更加容易得多。


对象间交互模式
1.直白的对象间交互
2.轻度抽象的对象间交互 delegate 基类
有两种方式可以做抽象，一种是使用多态的方式，把需要调度的方法或数据写在基类中，让调度者声明基类。然后响应者派生自基类，重载基类相关方法，从而达到调度者在无需知道响应者具体类型的情况下完成调度的目的。

另外一种做法是使用接口/协议（interface/protocol，后面我就都用接口来表述了）的方式，让调度者声明一个接口，然后响应者实现这个接口。这样也能同样做到调度者在无需知道响应者具体类型的情况下完成调度的任务。

接口方案无法给调度者提供默认实现，这就导致了调度者每次都要确保某个接口方法确实被实现了，才能走下一步的调度操作。
3.使用Target-Action淡化接口概念的对象间交互
一方面Target-Action可以在某种程度上理解成简化版的接口，另一方面也可以借助runtime的特性（也就是说前提是语言支持），Target-Action可以做到完全解耦，同时无视命名域是否完整
然而其随之而来的权衡就是失去了编译器检查
4.响应式的对象间交互
响应式思路发展到客户端，更多的是利用了响应式思路中主人无需认识仆人的这个特点，使得工程能够在较低耦合的情况下完成原来的任务。当然，模块的动态挂载也是比较常见的情况，例如页面出现时响应通知，页面消失时不响应通知也是很常见的情况。但这只是业务角度的特征，从架构角度去思考问题的话，我们更加侧重于响应式带来的低耦合的特点。

顺便扯一句，如果下一次有人问你delegate和notification有什么区别的时候，说一对一和一对多的区别就很low了，delegate模式也是能够实现出一对多的功能的(例如XMPP的multi delegate)。他们之间的本质区别就在于命令式和响应式。而且他们俩在避免轮询的角度上讲，是一模一样的，没有差别。
另外，响应式的本质其实就是Observer模式的应用。因此，Notification／Signal／Key-Value Observe就都可以被归类到响应式中。iOS场景中的KVO虽然也是属于响应式，但它的设计其实更多的是为了解决轮询问题，对于架构而言帮助不大。

闭包和其他所有方案比起来，最大的区别在于它能够抓取当前上下文的命名域，这也意味着：使用闭包的调用者完全不需要知道响应者的上下文，因为闭包已经把相关上下文都抓取了。响应者在闭包的创建和传递过程中，也可以做到完全不需要知道调用者的命名域。

推导过程
原始直白的对象间交互,由于这种最原始直白的交互方案要求对象必须要互相知道对方的具体类型。
在有些场合中，这种前提是不满足的。所以为了解决这个问题，就有了基于多态的方案和基于接口的方案。基于多态的方案使得调用者只要知道基类的声明，基于接口的方案只要知道接口的声明即可.
在Target-Action方案中，仍然有一个小遗憾。那就是调用者虽然可以不必了解响应者是什么对象，但调用者必须要拿到响应者实例。
在响应式对象间交互方案下，你再要找人办事，就已经不需要手上要有这个人了。你只需要吼一声，说你要办什么事。只要有人在听，自然就会把事情去办掉了。
但即使是在这种情况下，仍然还可以在业务场景中找得到缺陷：响应者必须要知道该听什么指令，而且响应者做的事情必须不能脱离命名域。缺陷就在于这个指令，指令可以体现为NotificationName，也可以体现为Signal。总之，这个指令必须是调用者知道，且响应者也能识别的
正因为闭包可以抓取上下文，跨越命名域传递，从而使得在命名域残缺不全的情况下完成对象间交互成为可能。当然，这里的前提是闭包的参数列表里面的参数不要受命名域的影响。所以很明显，闭包的最佳使用场景就是命名域残缺不全。
闭包方案在命名域残缺不全的同时，就带来了一个这样的限制：发起调用的地方和提供回调的地方必须要在同一上下文。

分析基于ReponderChain的对象交互方式
这种对象交互方式的缺点显而易见，它只能对存在于Reponder Chain上的UIResponder对象起作用。
优点倒是也有蛮多：
以前靠delegate层层传递的方案，可以改为这种基于Responder Chain的方式来传递。在复杂UI层级的页面中，这种方式可以避免无谓的delegate声明。
由于众多自定义事件都通过这种方式做了传递，就使得事件处理的逻辑得到归拢。在这个方法里面下断点就能够管理所有的事件处理。
使用Strategy模式优化之后，UIViewController/UIView的事件响应逻辑得到了很好的管理，响应逻辑不会零散到各处地方。
在此基础上使用Decorator模式，能够更加有序地收集、归拢数据，降低了工程的维护成本。
基于ResponderChain的对象交互方式的适用场景首先要求事件的产生和处理的对象都必须在Responder Chain上，这一点前面已经说过，我就不再赘述了。
它的适用场景还有一个值得说的地方，就是它可以无视命名域的存在。如果采用传统的delegate层层传递的方式，由于delegate需要protocol的声明，因此就无法做到命名域隔离。但如果走Responder Chain，即使是另一个UI组件产生了事件，这个事件就可以被传递到其他组件的UI上。

缩小包大小
LSUnusedResources 做正则删除
代码瘦身，使用LinkMap 结合 Mach-O 找无用代码
合并无用的轮子
删掉一些指令集


iOS crash收集
如何收集crash 使用Fabric收集，

崩溃主要是由于 Mach 异常、Objective-C 异常（NSException）引起的，同时对于 Mach 异常，到了 BSD 层会转换为对应的 Signal 信号，那么我们也可以通过注册 signalHandler 来捕获 Crash 事件。针对 NSException 可以通过注册 NSUncaughtExceptionHandler 捕获异常信息。

无法收集的crash
在你的程序退到后台以后，只有几秒钟的时间可以执行代码，接下来就会被系统挂起。进程挂起后所有线程都会暂停，不管这个线程是文件读写还是内存读写都会被暂停。但是，数据读写过程无法暂停只能被中断，中断时数据读写异常而且容易损坏文件，所以系统会选择主动杀掉 App 进程。
可以使用background task来使用三分钟后台，添加一个timer，如果时间到了三分钟到了，要停止操作

其他捕获不到的崩溃情况还有很多，主要就是内存打爆和主线程卡顿时间超过阈值被 watchdog 杀掉这两种情况。
也需要在临界状态，来主动收集

看crash 日志
方法调用栈顶，就是最后导致崩溃的方法调用。完整的崩溃日志里，除了线程方法调用栈还有异常编码。异常编码，就在异常信息里。
异常编码有44种

PPTV crash 分类
1.普通OC异常，方法未实现等，数组越界等 播放器的weak对象释放
2.KVO，notification 未移除
3.collectionview reload， 异步刷新，数据不同步，子线程操作等
4.野指针，线程安全 objc_retain崩溃 僵尸对象，或者自己实现
5.C++崩溃
6.runtime 交换崩溃
7.webview崩溃


性能问题
