1：讲讲你对atomic & nonatomic的理解
原子性，非原子性，atomic的属性，系统生成的get/set方法里面会加上锁。
但是atomic不能完全保证线程安全，因为可以通过_访问实例变量，或者例如i++之类的操作。
2：被 weak 修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable 么？里面的结构可以画出来么？
weak，弱引用的效果，不会retain对象，当对象被释放时，weak指针会被指向nil。
weak的妙用：weak单例，分类中的weak，使用block或者弱引用容器

3：block 用什么修饰？strong 可以？
copy, strong , arc可以, 函数内部的block在栈上，如果要在函数结束后调用，就要被copy到堆上，mrc时期要copy的，arc已经不用了
4：block 为什么能够捕获外界变量？ __block做了什么事？
clang重写的时候，block内部会把外部变量添加到自己的结构里面，__block可以让捕获行为从值的copy改成引用copy
5：谈谈你对事件的传递链和响应链的理解 （这个面试题，如果求职者能够回答一些实际开发相关的处理，不只是简单的概念，予以加分）
Hittest，pointinside，加大按钮，follrview
6：谈谈 KVC 以及 KVO 的理解？
kvc，键值编码模式，对象的实例变量可以通过key来访问，valueforkey
kvo，iOS中对观察者模式的实现，通过一个key，当属性发生变化时，通知被观察者。
kvo的崩溃和原理（通过runtime来动态添加子类，然后重写set）

7：RunLoop 的作用是什么？它的内部工作机制了解么？
一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出
线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。
CFRunLoop对外暴露的管理 Mode 接口只有下面2个:

CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
CFRunLoopRunInMode(CFStringRef modeName, ...);


8：苹果是如何实现 autoreleasepool的？
autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.

objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。
9：谈谈你对 FRP (函数响应式) 的理解，延伸一下 RxSwift 或者 RAC！
函数式，一个函数的结果只和入参有关，没有副作用，不引用全局变量，就是函数式，响应式，当一个量发生变化的时候，其他的值跟着变化
10：平时开发有没有玩过 Instrument？
发现内存泄漏，查看方法耗时，calltree
1：什么是 isa，isa 的作用是什么？

2：一个实例对象的isa 指向什么？类对象指向什么？元类isa 指向什么？

3：objc 中类方法和实例方法有什么本质区别和联系？

4：load 和 initialize 的区别？
load只会被调用一次，是类被加载到runtime环境时调用，分类也会有，是虚方法
initialize 是oc方法，会多次调用，他是类对象第一次被使用时，初始化调用的。。。。多继承的会多次调用，他走消息转发
5：_objc_msgForward 函数是做什么的？直接调用会发生什么问题？
方法没实现时，进行转发
6：简述下 Objective-C 中调用方法的过程

7：能否想向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
编译后不行，运行时可以。
8：谈谈你对切面编程的理解
aop，处理无痕埋点时比较好用

1：tableView 有什么好的性能优化方案？
2：界面卡顿和检测你都是怎么处理？
3：谈谈你对离屏渲染的理解？
4：如何降低APP包的大小 消除重复的图片资源，检测未调用过的代码和类
5：日常如何检查内存泄露？
6：APP启动时间应从哪些方面优化？

1：HTTP的缺陷是什么？
不安全，明文传输没有https的加密
2：谈谈三次握手，四次挥手！为什么是三次握手，四次挥手？
需要三次握手才能确认双方的接收与发送能力是否正常，第一次，客户端给服务端发，然后服务端给客户端发，然后客户端回复服务端
四次挥手
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了
服务器收到FIN包后，发送一个ACK给对方。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。
主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。

3：socket 连接和 Http 连接的区别
socket是套接字，是对TCP/IP的封装。它对数据传输的两者提供了一个全双工的管道。
它和http一样，传输数据前要经历三次握手链接也要经历四次挥手断开链接。和http协议的区别在于，socket是一个长链接。http是短连接。socket虽然是长链接，但是由于网络等原因也有可能会断开链接。所以往往会提供一个心跳包，每隔一段时间向服务器发送一个规定好的心跳，如果某一个时间发送没有收到心跳，那代表已经断开链接了。
http是应用层的协议，它实现了怎么发数据和怎么收数据，定义了收发的格式，同时定义了是短连接。当一次传输数据结束就断开链接。

4：HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数
拿到服务器公共的密匙后，生成随机对称密钥，用服务器密钥加密
5：HTTPS是什么？握手过程，SSL原理，非对称加密了解多少
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。

通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。

6：什么时候POP网路，有了 Alamofire 封装网络 URLSession为什么还要用Moya？

7：如何实现 dispatch_once
在加锁的情况下创建一个对象
8：能否写一个读写锁？谈谈具体的分析

9：什么时候会出现死锁？如何避免？

10：有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说


1：设计模式是为了解决什么问题的？
2：看过哪些第三方框架的源码，它们是怎么设计的？
3：可以说几个重构的技巧么？你觉得重构适合什么时候来做？
4：开发中常用架构设计模式你怎么选型?
5：你是如何组件化解耦的？
设计的六大原则
单一原则 简单地说就是一个类只做一件事
里氏替换原则 则当这个类需要修改时，必须考虑到所有的子类，
依赖倒置原则 在前面我们的例子中， RefusClient 实现类依赖于 接口（抽象），而不依赖于实现类（细节），这就是依赖倒置原则的体现。
接口隔离原则 接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。
迪米特原则 最少知识原则
开闭原则 因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。


1：tableView 有什么好的性能优化方案？
2： 界面卡顿和检测你都是怎么处理？
fps通过cadisplaylink检测
3：谈谈你对离屏渲染的理解？
对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作。
CALayer为这个方案提供了对应的解法：shouldRasterize。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染

但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片（ImageIO）渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。

CPU 资源消耗原因和解决方案
对象创建
对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多。
对象调整
对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。
对象销毁
对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。
布局计算
视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。
Autolayout
Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。
文本计算
如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。
文本渲染
屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。
图片的解码
当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。
图像的绘制
图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。

 GPU 资源消耗原因和解决方案
 纹理的渲染
 所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消 耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。
 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，
 视图的混合 (Composing)
 当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。
 图形的生成。

 CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。


4：如何降低APP包的大小
5：日常如何检查内存泄露？
6：APP启动时间应从哪些方面优化？


1.数据结构的存储一般常用的有几种？各有什么特点？
2.集合结构 线性结构 树形结构 图形结构
3.单向链表 双向链表 循环链表
4.数组和链表区别
5.堆、栈和队列
6.输入一棵二叉树的根结点，求该树的深度？
7.输入一课二叉树的根结点，判断该树是不是平衡二叉树

1.时间复杂度
2.空间复杂度
3.常用的排序算法
4.字符串反转
5.链表反转（头差法）
6.有序数组合并
7.查找第一个只出现一次的字符（Hash查找）
8.查找两个子视图的共同父视图
9.无序数组中的中位数(快排思想)
10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
