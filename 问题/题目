1：讲讲你对atomic & nonatomic的理解
原子性，非原子性，atomic的属性，系统生成的get/set方法里面会加上锁。
但是atomic不能完全保证线程安全，因为可以通过_访问实例变量，或者例如i++之类的操作。
2：被 weak 修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable 么？里面的结构可以画出来么？
weak，弱引用的效果，不会retain对象，当对象被释放时，weak指针会被指向nil。
weak的妙用：weak单例，分类中的weak，使用block或者弱引用容器

3：block 用什么修饰？strong 可以？
copy, strong , arc可以, 函数内部的block在栈上，如果要在函数结束后调用，就要被copy到堆上，mrc时期要copy的，arc已经不用了
4：block 为什么能够捕获外界变量？ __block做了什么事？
clang重写的时候，block内部会把外部变量添加到自己的结构里面，__block可以让捕获行为从值的copy改成引用copy
5：谈谈你对事件的传递链和响应链的理解 （这个面试题，如果求职者能够回答一些实际开发相关的处理，不只是简单的概念，予以加分）
Hittest，pointinside，加大按钮，follrview
6：谈谈 KVC 以及 KVO 的理解？
kvc，键值编码模式，对象的实例变量可以通过key来访问，valueforkey
kvo，iOS中对观察者模式的实现，通过一个key，当属性发生变化时，通知被观察者。
kvo的崩溃和原理（通过runtime来动态添加子类，然后重写set）

7：RunLoop 的作用是什么？它的内部工作机制了解么？
一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出
线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。
CFRunLoop对外暴露的管理 Mode 接口只有下面2个:

CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
CFRunLoopRunInMode(CFStringRef modeName, ...);


8：苹果是如何实现 autoreleasepool的？
autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.

objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。
9：谈谈你对 FRP (函数响应式) 的理解，延伸一下 RxSwift 或者 RAC！
函数式，一个函数的结果只和入参有关，没有副作用，不引用全局变量，就是函数式，响应式，当一个量发生变化的时候，其他的值跟着变化
10：平时开发有没有玩过 Instrument？
发现内存泄漏，查看方法耗时，calltree
1：什么是 isa，isa 的作用是什么？

2：一个实例对象的isa 指向什么？类对象指向什么？元类isa 指向什么？

3：objc 中类方法和实例方法有什么本质区别和联系？

4：load 和 initialize 的区别？
load只会被调用一次，是类被加载到runtime环境时调用，分类也会有，是虚方法
initialize 是oc方法，会多次调用，他是类对象第一次被使用时，初始化调用的。。。。多继承的会多次调用，他走消息转发
5：_objc_msgForward 函数是做什么的？直接调用会发生什么问题？
方法没实现时，进行转发
6：简述下 Objective-C 中调用方法的过程

7：能否想向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
编译后不行，运行时可以。
8：谈谈你对切面编程的理解
aop，处理无痕埋点时比较好用

1：tableView 有什么好的性能优化方案？

造成tableView卡顿的原因
1.没有使用cell的重用标识符，导致一直创建新的cell
2.cell的重新布局
3.没有提前计算并缓存cell的属性及内容
4.cell中控件的数量过多
5.使用了ClearColor，无背景色，透明度为0
6.更新只使用tableView.reloadData()（如果只是更新某组的话，使用reloadSection进行局部更新）
7.加载网络数据，下载图片，没有使用异步加载，并缓存
8.使用addView 给cell动态添加view
9.没有按需加载cell（cell滚动很快时，只加载范围内的cell）
10.实现无用的代理方法(tableView只遵守两个协议)
11.没有做缓存行高（estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。
建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可）
12.做了多余的绘制工作（在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制）
13.没有预渲染图像。（当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕）

2：界面卡顿和检测你都是怎么处理？
3：谈谈你对离屏渲染的理解？
4：如何降低APP包的大小 消除重复的图片资源，检测未调用过的代码和类
5：日常如何检查内存泄露？
6：APP启动时间应从哪些方面优化？


TCP和UDP的区别：
TCP为传输控制层协议，为面向连接、可靠的、点到点的通信；HTTP服务
UDP为用户数据报协议，非连接的不可靠的点到多点的通信；DNS服务
TCP侧重可靠传输，UDP侧重快速传输。


TCP/IP五层网络结构模型

物理层：物理层建立在物理通信介质的基础上，作为系统和通信介质的接口，用来实现数据链路实体间透明的比特 (bit) 流传输。只有该层为真实物理通信，其它各层为虚拟通信
数据链路层:在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据的单位称为帧（frame）
网络层：选择合适的路由，使数据分组（packet）可以交付到目的主机  http
传输层：负责主机中进程间的通信 tcp/udp
应用层：直接为用户的应用程序提供服务

Websocket
Websocket是同时基于HTTP与TCP来实现：

1：HTTP的缺陷是什么？
不安全，明文传输没有https的加密
2：谈谈三次握手，四次挥手！为什么是三次握手，四次挥手？
TCP的
需要三次握手才能确认双方的接收与发送能力是否正常，第一次，客户端给服务端发，然后服务端给客户端发，然后客户端回复服务端
四次挥手
这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了
服务器收到FIN包后，发送一个ACK给对方。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。
主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。

3：socket 连接和 Http 连接的区别
socket是套接字，是对TCP/IP的封装。它对数据传输的两者提供了一个全双工的管道。
它和http一样，传输数据前要经历三次握手链接也要经历四次挥手断开链接。和http协议的区别在于，socket是一个长链接。http是短连接。socket虽然是长链接，但是由于网络等原因也有可能会断开链接。所以往往会提供一个心跳包，每隔一段时间向服务器发送一个规定好的心跳，如果某一个时间发送没有收到心跳，那代表已经断开链接了。
http是应用层的协议，它实现了怎么发数据和怎么收数据，定义了收发的格式，同时定义了是短连接。当一次传输数据结束就断开链接。

4：HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数
拿到服务器公共的密匙后，生成随机对称密钥，用服务器密钥加密
5：HTTPS是什么？握手过程，SSL原理，非对称加密了解多少
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。
通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。
在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。
SSL握手：
有客户端发起的第一次握手，此次握手过程的主要目的是从服务端获取数字签名证书，服务端在发送数字签名证书之前要先确认客户端的SSL版本、加密算法等信息。
完成第一次握手后，接着进行第二次握手。第二次握手是在客户端收到证书后发起的，主要目的是将AES加解密使用的Key （Pre-master secret）发送给服务端。当然这个AES_KEY是使用第一次握手获取的公钥进行加密的。
当Client与Server端都持有AES_KEY后，就可以对HTTP报文进行加解密了。这里就不再是RSA了，而是使用对称加密，就算被第三方劫持，第三方也不知道密码。

6: 对称加密 非对称加密
1、对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。
2、非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。


7：如何实现 dispatch_once
在加锁的情况下创建一个对象
8：能否写一个读写锁？谈谈具体的分析

9：什么时候会出现死锁？如何避免？

10：有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说


1：设计模式是为了解决什么问题的？
2：看过哪些第三方框架的源码，它们是怎么设计的？
3：可以说几个重构的技巧么？你觉得重构适合什么时候来做？
4：开发中常用架构设计模式你怎么选型?
5：你是如何组件化解耦的？
设计的六大原则
单一原则 简单地说就是一个类只做一件事
里氏替换原则 则当这个类需要修改时，必须考虑到所有的子类，
依赖倒置原则 在前面我们的例子中， RefusClient 实现类依赖于 接口（抽象），而不依赖于实现类（细节），这就是依赖倒置原则的体现。
接口隔离原则 接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。
迪米特原则 最少知识原则
开闭原则 因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。


1：tableView 有什么好的性能优化方案？
2：界面卡顿和检测你都是怎么处理？
fps通过cadisplaylink检测
3：谈谈你对离屏渲染的理解？
对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作。
CALayer为这个方案提供了对应的解法：shouldRasterize。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染

但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片（ImageIO）渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。

4：如何降低APP包的大小
5：日常如何检查内存泄露？
6：APP启动时间应从哪些方面优化？


Swift系列面试题
1.类(class) 和 结构体(struct) 有什么区别? 类(class) 和 结构体(struct) 比较,优缺点?

struct是值类型，class是引用类型。
值类型的变量直接包含它们的数据，对于值类型都有它们自己的数据副本，因此对一个变量操作不可能影响另一个变量。
引用类型的变量存储对他们的数据引用，因此后者称为对象，因此对一个变量操作可能影响另一个变量所引用的对象。
二者的本质区别：struct是深拷贝，拷贝的是内容；class是浅拷贝，拷贝的是指针。

property的初始化不同：class 在初始化时不能直接把 property 放在 默认的constructor 的参数里，而是需要自己创建一个带参数的constructor；而struct可以，把属性放在默认的constructor 的参数里。
变量赋值方式不同：struct是值拷贝；class是引用拷贝。
immutable变量：swift的可变内容和不可变内容用var和let来甄别，如果初始为let的变量再去修改会发生编译错误。struct遵循这一特性；class不存在这样的问题。
mutating function： struct 和 class 的差別是 struct 的 function 要去改变 property 的值的时候要加上 mutating，而 class 不用。
继承： struct不可以继承，class可以继承。
struct比class更轻量：struct分配在栈中，class分配在堆中。

2.Swift 是面向对象还是函数式的编程语言?
Swift 既是面向对象的，又是函数式的编程语言。
说 Swift 是面向对象的语言，是因为 Swift 支持类的封装、继承、和多态，从这点上来看与 Java 这类纯面向对象的语言几乎毫无差别。
说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce, filter, flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。

3.什么是高阶函数
一个函数如果可以以某一个函数作为参数, 或者是返回值, 那么这个函数就称之为高阶函数, 如 map, reduce, filter

4.定义静态方法时关键字 static 和 class 有什么区别
static 定义的方法不可以被子类继承, class 则可以

5.比较以下关键词：Open, Public, Internal, File-private, Private
Swift 有五个级别的访问控制权限，从高到底依次为比如 Open, Public, Internal, File-private, Private。

他们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个 private 的 class 中不能含有 public 的 String。反之，低级别的变量却可以定义在高级别的变量中。比如 public 的 class 中可以含有 private 的 Int。

Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module 中被访问和重写；它是 Swift 3 中新添加的访问权限。
Public 的权限仅次于 Open。与 Open 唯一的区别在于它修饰的对象可以在任意 Module 中被访问，但不能重写。
Internal 是默认的权限。它表示只能在当前定义的 Module 中访问和重写，它可以被一个 Module 中的多个文件访问，但不可以被其他的 Module 中被访问。
File-private 也是 Swift 3 新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的 class，extension，struct 共同使用。
Private 是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。

6.swift 为什么将 String,Array,Dictionary设计为值类型?
值类型和引用类型相比,最大优势可以高效的使用内存,值类型在栈上操作,引用类型在堆上操作,栈上操作仅仅是单个指针的移动,而堆上操作牵涉到合并,位移,重链接,Swift 这样设计减少了堆上内存分配和回收次数,使用 copy-on-write将值传递与复制开销降到最低
7.如何将Swift 中的协议(protocol)中的部分方法设计为可选(optional)?
在协议和方法前面添加 @objc,然后在方法前面添加 optional关键字,改方式实际上是将协议转为了OC的方式
2.使用扩展(extension),来规定可选方法,在 swift 中,协议扩展可以定义部分方法的默认实现

8.比较Swift 和OC中的初始化方法 (init) 有什么不同?
swift 的初始化方法,更加严格和准确, swift初始化方法需要保证所有的非optional的成员变量都完成初始化, 同时 swfit 新增了convenience和 required两个修饰初始化器的关键字
convenience只提供一种方便的初始化器,必须通过一个指定初始化器来完成初始化
required是强制子类重写父类中所修饰的初始化方法

9.什么是函数重载? swift 支不支持函数重载?
函数重载是指: 函数名称相同,函数的参数个数不同, 或者参数类型不同,或参数标签不同, 返回值类型与函数重载无关
swift 支持函数重载

10.swift 中的枚举,关联值 和 原始值的区分?
关联值--有时会将枚举的成员值跟其他类型的变量关联存储在一起，会非常有用
// 关联值
enum Date {
  case digit(year: Int, month: Int, day: Int)
  case string(String)
}

原始值--枚举成员可以使用相同类型的默认值预先关联，这个默认值叫做:原始值
// 原始值
enum Grade: String {
  case perfect = "A"
  case great = "B"
  case good = "C"
  case bad = "D"
}

11、swift 中的闭包结构是什么样子的?什么是尾随闭包?什么是逃逸闭包?什么是自动闭包?
尾随闭包
将一个很长的闭包表达式作为函数的最后一个实参
使用尾随闭包可以增强函数的可读性
尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式

非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数
非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内
逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明

自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。

func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -> Int) -> Int? {
    return v1 > 0 ? v1 : v2()
}
getFirstPositive(10, 20)

12.swift中, 存储属性和计算属性的区别?
Swift中跟实例对象相关的属性可以分为2大类

存储属性(Stored Property)

类似于成员变量这个概念
存储在实例对象的内存中
结构体、类可以定义存储属性
枚举不可以定义存储属性
计算属性(Computed Property)

本质就是方法(函数)
不占用实例对象的内存
枚举、结构体、类都可以定义计算属性

struct Circle {
    // 存储属性
    var radius: Double
    // 计算属性
    var diameter: Double {
        set {
            radius = newValue / 2
        }
        get {
            return radius * 2
        }
    }
}

13.swift 中如何使用单例模式?
可以通过类型属性+let+private 来写单例; 代码如下如下:

 public class FileManager {
    public static let shared = {
        // ....
        // ....
        return FileManager()
}()
    private init() { }
}

14.swift 中的下标是什么?
使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本
subscript的语法类似于实例方法、计算属性，本质就是方法(函数)


git rebase 和merge
rebase会把分支提交记录也合并上主分支
